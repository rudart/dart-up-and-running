# Классы

Dart - это объектно-ориентированный язык с классами и примесями. Кажный объект является экземпляром класса, а все классы являются наследниками [Object](http://api.dartlang.org/dart_core/Object.html). Наследование на основе примесей означает то, что хотя каждый класс может меть только один суперкласс (только одного предка), тело класса может быть повторно использовано в нескольких классах (подробнее об этом будет рассказано ниже).

Для создания объекта можно использовать ключевое слово `new` вместе с *конструктором* класса. Имя конструктора может быть **ClassName** или **ClassName.identifier**. Например:

```java
var jsonData = JSON.decode('{"x":1, "y":2}');

var p1 = new Point(2,2);               // Создание Point через конструктор Point().
var p2 = new Point.fromJson(jsonData); // Cоздание Point через конструктор Point.fromJson().
```

У объектов есть члены, *методы* и *свойства*. Когда вы вызываете метод, то вы вызываете его "на объекте": метод имеет доступ к другим методам и свойствам объекта.

Используйте точку (**.**) для доступа к методам или свойствам объекта:

```java
var p = new Point(2,2);

p.y = 3;             // Установка значения свойства y.
assert(p.y == 3);    // Получение значения свойства y.

num distance = p.distanceTo(new Point(4,4)); // Вызов функции distanceTo() объекта p.
```

Используйте оператор каскадного доступа (**..**), когда хотите выполнить ряд операций над одним объектом:

```java
querySelector('#button')
    ..text = 'Click to Confirm'                        // Получение объекта и работа с
    ..classes.add('important')                         // его свойствами и методами
    ..onClick.listen((e) => window.alert('Confirmed!'));
```

Некоторые классы предоставляют конструкторы констант. Для создания compile-time констант используйте `const` вместо `new`:

```java
var p = const ImmutablePoint(2,2);
```

Создание двух одинаковых compile-time констант приведет к созданию одного объекта:

```java
var a = const ImmutablePoint(1, 1);
var b = const ImmutablePoint(1, 1);

assert(identical(a,b)); // Это один и тот же объект
```

## Переменные экземпляров

Вот как объявляются переменные экземпляров:

```java
class Point {
  num x; // x после инициализации объекта будет null
  num y; // y после инициализации объекта будет null
  num z = 0; // z после инициализации объекта будет 0
}
```

Все неинициализированные переменные экземпляра будут хранить значение `null`.

Все переменные экземпляра создают "скрытый" *getter-метод* (геттер). Переменные, которые не являются `final` также создают *setter-метод* (сеттер). Подробнее об этом будет рассказано ниже.

```java
class Point {
  num x;
  num y;
}

main() {
  var point = new Point();
  point.x = 4;             // Использование сеттера для x.
  assert(point.x == 4);    // Использование геттера для  x.
  assert(point.y == null); // По-умолчанию значение переменной null.
}
```

При инициализации объекта, значение переменной экземпляра устанавливается до выполнения конструктора.

## Конструкторы

Для создания конструктора нужно объявить функцию с таким же именем, как и имя класса (также можно добавить дополнительный идентификатор конструктора - это будет описано ниже, в разделе "Именованные конструкторы"). Наиболее распорстраненная форма конструктора - пораждающий конструктор, который создает новый экземпляр класса:

```java
class Point {
  num x;
  num y;

  Point(num x, num y) {
    this.x = x;
    this.y = y;
  }
}
```

Ключевое слово `this` ссылается на текущий экземпляр.

> **Примечание**
>
> Используйте `this` только тогда, когда может быть конфликт имен.

Форма присвоения значений переменным экземпляра при создании объекта очень распространена и в Dart для этого случая есть "синтаксический сахар":

```java
class Point {
  num x;
  num y;

  // Синтаксический сахар для установки значений x и y
  // перед выполнением тела конструктора
  Point(this.x, this.y);
}
```

### Стандартный конструктор

Если вы не объявите конструктор, то это будет сделано за вас. Стандартный конструктор не принимает аргументов и вызывает конструктор суперкласса без аргументов.

### Конструкторы не наследуются

Подклассы не наследуют конструкторы от суперклассов. Подкласс, у которого не объявлены конструкторы имеет только один стандартный конструктор.

### Именованные конструкторы

Используйте именованные конструкторы для того, чтобы реализовать несколько конструкторов класса или обеспечить большую ясность:

```java
class Point {
  num x;
  num y;

  Point(this.x, this.y);

  // Именованный конструктор
  Point.fromJson(Map json) {
    x = json['x'];
    y = json['y'];
  }
}
```

Помните, что конструкторы не наследуются. Это значит, что именованные конструкторы суперкласса не будут наследоваться подклассом. Если вы хотите, чтобы подкласс был создан с именованными конструкторами суперкласса, вы должны определить эти конструкторы в подклассе.

### Вызов не стандартного конструктора суперкласса

По-умолчанию, конструкторы подклассов вызывают стандартный конструктор суперкласса (без аргументов). Если суперкласс не имеет такого конструктора, то вы должны вручную вызвать один из конструкторов суперкласса. Конструктор суперкласса указывается после двоеточия (**:**) и перед телом конструктора (если оно есть).

```java
class Person {
  Person.fromJson(Map data) {
    print('in Person');
  }
}

class Employee extends Person {
  // Person не имеет стандартного конструктора;
  // поэтому мы будем использовать super.fromJson(data).
  Employee.fromJson(Map data) : super.fromJson(data) {
    print('in Employee');
  }
}

main() {
  var emp = new Employee.fromJson({});

  // Вывод:
  // in Person
  // in Employee
}
```

Так как аргументы конструктора суперкласса мы получаем перед выполнением конструктора, то аргументом может быть и выражение, например, функция:

```java
class Employee extends Person {
  ...
  Employee() : super.fromJson(findDefaultData());
}
```

> **Предупреждение**
>
> Аргументы конструктора суперкласса не имеют доступа к `this`. Например, аргумент может вызывать статический метод класса, но не метод экземпляра.

### Список инициализации

Кроме вызова конструктора суперкласса, вы также можете инициализировать переменные экземпляра перед выполнением тела конструктора:

```java
class Point {
  num x;
  num y;

  Point(this.x, this.y);

  Point.fromJson(Map json) : x = json['x'], y = json['y'] {
    print('In Point.fromJson(): ($x, $y)');
  }
}
```

> **Предупреждение**
>
> Правая часть выражения инициализации не имеет доступа к `this`.

### Перенаправленные конструкторы

Порой целью конструктора является перенаправление на другой конструктор того же класса. Тело перенаправленного конструктора остается пустым, а вызов нужного конструктора указывается после двоеточия (**:**):

```java
class Point {
  num x;
  num y;

  Point(this.x, this.y);                // Главный конструктор класса.
  Point.alongXAxis(num x) : this(x, 0); // Перенаправление на главный конструктор.
}
```

### Конструкторы констант

Если ваш класс создает объекты, которые никогда не изменяются, то можно сделать эти объекты compile-time константами. Для того, чтобы это сделать, определите `const`-конструктор и удостовертесь, что все переменные класса являются `final`.

```java
class ImmutablePoint {
  final num x;
  final num y;
  const ImmutablePoint(this.x, this.y);
  static final ImmutablePoint origin = const ImmutablePoint(0, 0);
}
```

### Конструкторы-фабрики

Используйте ключевое слово `factory` для создания конструктора, который не должен каждый раз создавать объект текущего класса. Например, конструктор-фабрика может возвращать объект из кеша, или объект подкласса.

Пример ниже показывает как конструктор-фабрика возвращает объекты из кеша:

```java
class Logger {
  final String name;
  bool mute = false;

  // _cache - приватная переменная на уровне библиотеки.
  static final Map<String, Logger> _cache = <String, Logger>{};

  factory Logger(String name) {
    if (_cache.containsKey(name)) {
      return _cache[name];
    } else {
      final logger = new Logger._internal(name);
      _cache[name] = logger;
      return logger;
    }
  }

  Logger._internal(this.name);

  void log(String msg) {
    if (!mute) {
      print(msg);
    }
  }
}
```

> **Примечание**
>
> Конструкторы-фабрики не имеют достпа к `this`.

Для вызова конструктора-фабрики используйте ключевое слово `new`:

```java
var logger = new Logger('UI');
logger.log('Button clicked');
```

## Методы

Методы - это функции, которые определяют поведение объекта.

### Методы экземпляра

Методы экземпляра имеют доступ к переменным экземпляра и к `this`. В примере ниже, метод `distanceTo()` является методом экземпляра:

```java
import 'dart:math';

class Point {
  num x;
  num y;
  Point(this.x, this.y);

  num distanceTo(Point other) {
    var dx = x - other.x;
    var dy = y - other.y;
    return sqrt(dx * dx + dy * dy);
  }
}
```

### Getters и Setters (геттеры и сеттеры)

Геттеры и сеттеры - это специальные методы, которые обеспечивают доступ для чтения и записи свойств объекта. Напомним, что каждая переменная класса определяет геттер, и (если это возможно) - сеттер. Вы можете создать дополнительные свойства для реализации геттеров и сеттеров, используя ключевые слова `get` и `set`:

```java
class Rectangle {
  num left;
  num top;
  num width;
  num height;

  Rectangle(this.left, this.top, this.width, this.height);

  // Опрелим два ствойва: right и bottom.
  num get right             => left + width;
      set right(num value)  => left = value - width;
  num get bottom            => top + height;
      set bottom(num value) => top = value - height;
}

main() {
  var rect = new Rectangle(3, 4, 20, 15);
  assert(rect.left == 3);
  rect.right = 12;
  assert(rect.left == -8);
}
```

> **Примечание**
>
> Такие операторы, как оператор приращения (**++**) может работать некорректно в том случае, если он работает с геттером. Для того, чтобы избежать неявного поведения оператор вызывает геттер только один раз, после чего сохраняет значение во временную переменную.

### Абстрактные методы

Методы экземпляра, геттеры или сеттеры могут быть абстрактными, определяя интерфейс, но опуская реализацию методов. Для того, чтобы сделать метод абстракным, поставте точку с запятой вместо тела метода:

```java
abstract class Doer {
  // ...Определение переменных и методов экземпляра...

  void doSomething(); // Определение абстрактного метода.
}

class EffectiveDoer extends Doer {
  void doSomething() {
    // ...Тело метода, т.к. в этом классе он уже не абстрактный...
  }
}
```

Вызов абстрактного метода приведет к ошибке времени выполнения.

### Переопределение операторов

Вы можете переопределить следующие операторы:

* <
* >
* <=
* >=
* -
* +
* /
* ~/
* *
* %
* |
* ^
* &
* <<
* >>
* []
* []=
* ~
* ==

Например, если вы создали класс `Vector`, вы можете перекрыть оператор `+` для реализации сложения двух векторов. Вот пример перекрытия операторов `+` и `-`:

```java
class Vector {
  final int x;
  final int y;
  const Vector(this.x, this.y);

  Vector operator +(Vector v) { // Перекрываем + (a + b).
    return new Vector(x + v.x, y + v.y);
  }

  Vector operator -(Vector v) { // Перекрываем - (a - b).
    return new Vector(x - v.x, y - v.y);
  }
}

main() {
  final v = new Vector(2,3);
  final w = new Vector(2,2);

  assert(v.x == 2 && v.y == 3);         // v   == (2,3)
  assert((v+w).x == 4 && (v+w).y == 5); // v+w == (4,5)
  assert((v-w).x == 0 && (v-w).y == 1); // v-w == (0,1)
}
```

Если вы перекрываете `==`, то вы также должны переопределить геттер `hashCode`.

## Абстрактные классы

Используйте ключевое слово `abstract` для создания *абстрактного* класса - класс, экземпляр которого нельзя создать. Абстрактные классы полезны для определения интерфейсов. Если вы хотите, чтобы ваш абстрактный класс мог создавать экземпляры, то определите **конструктор-фабрику**.

Абстрактные классы часто имеют **абстрактные методы**. Вот пример определения абстрактного класса, у которого есть абстрактный метод:

```java
// Класс асбстрактный, поэтому его экземпляр создать нельзя.
abstract class AbstractContainer {
  // ...Конструкторы, свойства, методы...

  void updateChildren(); // Абстрактный метод.
}
```

Класс ниже не абстрактный, поэтому мы можем создать его экземпляр, даже если в нем определен абстрактный метод:

```java
class SpecializedContainer extends AbstractContainer {
  // ...Конструкторы, свойства, методы...

  void updateChildren() {
    // ...Реализация updateChildren()...
  }
// Абстрактный метод сгенерирует пердупреждение, но не прервет создание объекта.
  void doSomething();
}
```

## Неявные интерфейсы

Каждый класс является еще и интерфейсом, содержащим все переменные экземпляра класса и реализацию других интерфейсов. Если вы хотите создать класс `A`, поддерживающий API класса `B`, без наследования `B`, то класс `A` должен реализовать интерфейс класса `B`.

Класс может реализовывать несколько интерфейсов, определенных после ключевого слова `implements`:

```java
// Неявный интерфейс Person, содежращий метод greet().
class Person {
  final _name;          // Принадлежит интерфейсу. Видимость во всей библиотеке,
  Person(this._name);   // Не принадлежит интерфейсу, если класс используется как интерфейс.
  String greet(who) => 'Hello, $who. I am $_name.'; // Принадлежит интерфейсу
}

// Реализация интерфейса Person
class Imposter implements Person {
  final _name = "";      // Мы дважды определяем эту переменную, но не используем ее.
  String greet(who) => 'Hi $who. Do you know who I am?';
}

greetBob(Person person) => person.greet('bob');

main() {
  print(greetBob(new Person('kathy')));
  print(greetBob(new Imposter()));
}
```

Пример класса, который реализует несколько интерфейсов:

```java
class Point implements Comparable, Location {
  // ...
}
```

## Расширение класса

Используйте ключевое слово `extends` для создания подкласса, а `super` - для обращения к суперклассу.

```java
class Television {
  void turnOn() {
    _illuminateDisplay();
    _activateIrSensor();
  }
  ...
}

class SmartTelevision extends Television {
  void turnOn() {
    super.turnOn();
    _bootNetworkInterface();
    _initializeMemory();
    _upgradeApps();
  }
  ...
}
```

Подклассы могут перекрывать методы экземпляров, геттеры и сеттеры. Вот пример перекрытия метода `noSuchMethod()` класса `Object`, который вызывается тогда, когда мы обращаемся к несуществующему методу или свойству:

```java
class A {
  // Если не переопределить noSuchMethod, то обращение к
  // несуществующему члену приведет к NoSuchMethodError.
  void noSuchMethod(Invocation mirror) {
    print('Вы пытаетесь обратиться к несуществующему члену: ${mirror.memberName}');
  }
}
```

Если вы используете `noSuchMethod()` для реализации всевозможных геттеров, сеттеров и методов класса, тогда используйте аннотацию `@proxy` для скрытия предупреждений:

```java
@proxy
class A {
  void noSuchMethod(Invocation mirror) {
    // ...
  }
}
```

Для более подробной информации смотрите статью "[Метаданные](https://www.dartlang.org/docs/dart-up-and-running/contents/ch02.html#ch02-metadata)".

## Добавление возможностей к классу: примеси

Примеси - это способ повторного использования кода класса в других классах.

Для использования примесей укажите ключевое слово `with`, за которым будет следовать одно или несколько имен примесей. Следующий пример демонстрирует два класса, которые используют примеси:

```java
class Musician extends Performer with Musical {
  ...
}

class Maestro extends Person with Musical, Aggressive, Demented {
  Maestro(String maestroName) {
    name = maestroName;
    canConduct = true;
  }
}
```

Для создания примеси, создайте класс, который расширяет `Object`, не определяет конструкторов и не обращается к суперклассу:

```java
abstract class Musical {
  bool canPlayPiano = false;
  bool canCompose = false;
  bool canConduct = false;

  void entertainMe() {
    if (canPlayPiano) {
      print('Playing piano');
    } else if (canConduct) {
      print('Waving hands');
    } else {
      print('Humming to self');
    }
  }
}
```

Для более подробной информации смотрите статью "[Примеси в Dart](http://www.dartlang.org/articles/mixins/)".

## Переменные и методы класса

Используйте ключевое слово `static` для создания переменных и методов класса.

### Переменные класса

```java
class Color {
  static const RED = const Color('red'); // статичная константа.
  final String name;                     // переменная экземпляра.
  const Color(this.name);                // конструктор констант.
}

main() {
  assert(Color.RED.name == 'red');
}
```

Статичные переменные не инициализируются до тех пор, пока к ним не обратятся.

### Методы класса

Методы класса (статичные методы) не работают с объектом и не имеют доступ к `this`.

```java
import 'dart:math';

class Point {
  num x;
  num y;
  Point(this.x, this.y);

  static num distanceBetween(Point a, Point b) {
    var dx = a.x - b.x;
    var dy = a.y - b.y;
    return sqrt(dx * dx + dy * dy);
  }
}

main() {
  var a = new Point(2, 2);
  var b = new Point(4, 4);
  var distance = Point.distanceBetween(a,b);
  assert(distance < 2.9 && distance > 2.8);
}
```

> **Примечание**
>
> Рассмотрите варинт использования top-level функция вместо статических  методов для реализации общих или широко используемых функций.

Вы можете использовать методы класса как compile-time константы. Например, вы можете передавать статичный метод как параметр конструктору.
