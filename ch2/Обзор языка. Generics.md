# Обзор языка. Generics (Обобщения)

Если вы посмотрите документацию для класса [List](http://api.dartlang.org/dart_core/List.html), то увидите, что он объявлен как `List<E>`. Нотация `<...>` говорит о том, что `List` является обобщенным (параметризованным) типом - тип, который имеет формальный параметр типа. По соглашению, переменные типа состоят из одного символа: `E`, `T`, `S`, `K`, `V`.

## Зачем использовать generics (обобщения)

Т.к. объявление типов в Dart является не обязательным, вы можете никогда не использовать обобщения. Но вы должны стремиться к этому по нескольким причинам: типы (обобщения или нет) делают ваш код более понятным и чистым.

Например, если вы уверены, что массив будет содержать только строки, то вы можете объявить его как `List<String>` (массив строк). Так вы, другие программисты и утилиты смогут легко обнаружить вероятное место ошибки. Вот пример:

```java
var names = new List<String>();
names.addAll(['Seth', 'Kathy', 'Lars']);
// ...
names.add(42); // В checked-mode будет ошибка. В production-mode - все хорошо отработает.
```

Вторая причина использования обобщений - снизить повторяемость кода. Обобщения дают вам возможность предоставить единый интерфейс и реализацию для многих типов. Например, вы хотите создать интерфейс для объекта кеша:

```java
abstract class ObjectCache {
  Object getByKey(String key);
  setByKey(String key, Object value);
}
```

Затем вы хотите добавить кеш, который работает только со строками, поэтому создаете другой интерфейс:

```java
abstract class StringCache {
  String getByKey(String key);
  setByKey(String key, String value);
}
```

После этого вы хотите создать интерфейс кеша, который будет работать с числами... Ну, вы поняли мысль.

Generiс-типы помогут решить эту проблему с созданием большого количества интерфейсов. Вы можете создать один интерфейс, который будет принимать параметр типа:

```java
abstract class Cache<T> {
  T getByKey(String key);
  setByKey(String key, T value);
}
```

В коде выше, `T` - это ожидаемый тип. Это плейсхолдер типа, который разработчик определит позже.

## Использование литерала коллекции

Литералы списка и хэша (map) могут быть параметризованы. Параметризованные литералы выглядят так же, как и те, что вы уже видели, но добавляется `<type>` (для списков) или `<keyType, valueType>` (для хэшей) перед открывающей скобкой. Вы можете использовать параметризованные литералы, если хотите получить предупреждения в checked-mode. Пример:

```java
var names = <String>['Seth', 'Kathy', 'Lars'];
var pages = <String, String>{
    'index.html':'Homepage',
    'robots.txt':'Hints for web robots',
    'humans.txt':'We are people, not machines' };
```

## Параметризация типов при создании объекта через конструктор

Для указания одного или нескольких типов при создании объекта через конструктор поместите типы в `<...>` сразу после имени класса. Например:

```java
var names = new List<String>();
names.addAll(['Seth', 'Kathy', 'Lars']);
var nameSet = new Set<String>.from(names);
```

Следующий пример создает map, ключи которого являются целочисленными значениями, а значения - объектами `View`:

```java
var views = new Map<int, View>();
```

## Generic-коллекции и типы, которые они содержат

Обобщенные типы *овеществляются* в Dart, что значит, что они хранят информацию о типе объекта. Пример ниже лучше раскроет эту мысль. В нем производится проверка типа коллекции:

```java
var names = new List<String>();
names.addAll(['Seth', 'Kathy', 'Lars']);
print(names is List<String>); // true
```

Выражение `is` проверяет только тип коллекции, но не проверяет тип объектов, которые находятся внутри. В production-mode `List<String>` может содержать объекты различных типов.

Для более подробной информации смотрите статью "[Необязательные типы в Dart](http://www.dartlang.org/articles/optional-types/)".
