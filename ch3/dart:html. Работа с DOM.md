# dart:html. Работа с DOM

Если вы хотите использовать DOM, Вам должны быть известны объекты `window`, `document`, `elements`, и `nodes`.

Объект [Window](http://api.dartlang.org/html/Window.html), представляет окно браузера. Каждое окно имеет объект `Document`, который указывает на загруженный в данный момент документ. Объект `Window` также имеет средства доступа к различным API, такие как `IndexedDB` (для хранения данных), `requestAnimationFrame` (для анимации), и многое другое. В браузерах каждая вкладка имеет свой собственный объект `Window`.

Используя объект [Document](http://api.dartlang.org/html/Document.html) можно создавать и манипулировать [элементами (Elements)](http://api.dartlang.org/html/Element.html) этого документа. Следует отметить, что объект `Document` сам является элементом и им тоже можно управлять.

DOM представляет собой дерево [узлов (Nodes)](http://api.dartlang.org/html/Node.html). Чаще всего они являются элементами, также они могут быть атрибутами, текстом, комментариями и другими типами DOM. За исключением самого первого узла (root node), который не имет родительского элемента, каждый узел в DOM имеет одного родителя и может иметь много потомков.

## Поиск элементов

Для манипулирования элементом, сперва нужен объект который будет представлять этот элемент. Этот объект можно получить используя запросы.

Для поиска одного или нескольких элементов используются функции высшего уровня `querySelector()` и `querySelectorAll()`. Запрос может быть произведен по id, классу, тегу, имени или по любой из этих комбинаций. [Спецификация CSS](http://www.w3.org/TR/css3-selectors/) определяет формат селекторов таких как `"#"` - для ID, и `"."` - для классов.

Функция `querySelector()` возвращает первый элемент, который соответствует запросу, в то время как `querySelectorAll()` возвращает коллекцию всех элементов, которые соответствуют запросу.

```java
Element elem1 = querySelector('#an-id');           // Отбирается элемент по идентификатору (an-id).
Element elem2 = querySelector('.a-class');         // Отбираются элемент по классу (a-class).
List<Element> elems1 = querySelectorAll('div');    // Отбираются все элементы по тегу (<div>).
List<Element> elems2 = querySelectorAll('input[type="text"]'); // Отбираются все поля для ввода текста.
   
// Находятся все элементы с CSS классом 'class' внутри тега <p>
// которые находятся в элементе с ID 'id'.
List<Element> elems3 = querySelectorAll('#id p.class');
```
   
## Манипулирование элементами

Вы можете использовать свойства для изменения состояния элемента. Класс `Node` и его подтип `Element` определяют все свойства которые имеют элементы. К примеру все элементы имеют `classes`, `hidden`, `id`, `style`, и `title` -свойства которые вы можете использовать для установки состояния. Подклассы класса `Element` определяют дополнительные свойства, такие как `href`, который принадлежит классу [AnchorElement](http://api.dartlang.org/html/AnchorElement.html).

Пример использования элемента ссылки в html:

```java
<a id="example" href="http://example.com">Текст ссылки</a>
```

Тег `<a>` определяет элемент с атрибутом `href` и текстовым узлом (доступным через свойства) который содержит текст "Текст ссылки". Для изменения URL ссылки может быть использовано свойство `href` объекта `AnchorElement`:

```java
querySelector('#example').href = 'http://dartlang.org';
```

Часто бывает необходимо установить свойства для многих элементов. Например, следующий код устанавливает свойство `hidden` для всех элементов, которые имеют класс "mac", "win" или "linux". Установка свойства `hidden` в значение `true` имеет тот же эффект что и `display:none` в CSS.

```java
<!-- In HTML: -->
<p>
  <span class="os linux">Words for Linux</span>
  <span class="os mac">Words for Mac</span>
  <span class="os win">Words for Windows</span>
</p>
// In Dart:
final osList = ['mac', 'win', 'linux'];

var userOs = 'linux'; // В реальном коде нужно определять это программным путем.

for (var os in osList) {            // Для каждой возможной OS...
  bool shouldShow = (os == userOs); // Проверяется соответствует ли эта os os пользователя 
  for (var elem in querySelectorAll('.$os')) { // Находятся все элементы для этой OS.
    elem.hidden = !shouldShow;      // Каждый элемент можно скрыть или показать.
  }
}
```

Когда нужное свойство недоступно или отсутствует, Вы можете использовать свойство `attributes`. Свойство `attributes` - это хеш `Map<String, String>`, где ключи являются именами атрибутов. Чтобы увидеть весь список атрибутов и их значений посмотрите [страницу на MDN](https://developer.mozilla.org/en/HTML/Attributes). Вот пример установки значения атрибута: 

```java
elem.attributes['someAttribute'] = 'someValue';
```

## Создание элементов

Элементы можно создавать и добавлять в DOM существующих html страниц. Пример создание параграфа (`<p>`):

```java
var elem = new ParagraphElement();
elem.text = 'Creating is easy!';
```

Элемент также можно создать путем парсинга html разметки. Любой вложенный элемент будет проанализирован и создан.

```java
var elem2 = new Element.html('<p>Creating <em>is</em> easy!</p>');
```

Следует отметить, что `elem2` является `ParagraphElement` в приведенном выше примере.

Добавляя созданный элемент в документ, можно назначить его родительский элемент. Вы можете добавить элемент в любой другой существующий элемент. В следующем примере `body` является элементом, а его вложенные элементы можно получить через свойствo `children` (`List<Element>`).

```java
document.body.children.add(elem2);
```

## Добавление, замещение и удаление элементов

Напомню, что элементы являются своего рода узлами. Вы можете отобрать все вложенные элементы узла используя свойство `nodes` объекта `Node`, которое возвращается в виде списка `List<Node>` (за исключением потомков которые не являются узлами Element). Если у Вас есть этот список, Вы можете использовать обычные методы объекта `List` и его операторы для манипулирования потомками узла.

Для добавления потомка в качестве последнего элемента содержащего его узла, используется метод объекта `List` - `add()`:

```java
// По id находится родительский элемент и в качестве последнего потомка добавляется новый элемент elem
querySelector('#inputs').nodes.add(elem);
```

Для замены узла используется метод объекта `Node` `replaceWith()`:

```
// Узел находится по ID, и заменяется прямо в DOM.
querySelector('#status').replaceWith(elem);
```

Чтобы удалить узел используется метод `remove()`:

```java
// Отбирается узел по id, и удаляется из DOM.
querySelector('#expendable').remove();
```

## Манипулирование CSS стилями

CSS или каскадные таблицы стилей определяют внешний вид элементов DOM. Добавляя к элементу атрибуты `id` или `class`, Вы можете изменять его внешний вид.

Каждый элемент имеет свойство `classes`, которое представляет собой список. Добавление или удаление классов CSS в элемент представляет собой простое добавление или удаление строк из этой коллекции. В следующем примере к элементу просто добавляется класс **warning**:

```java
var element = querySelector('#message');
element.classes.add('warning');
```

Часто очень эффективно отбирать элементы из DOM по ID. Вы можете динамически устанавливать идентификаторы элемента используя свойство `id`:

```java
var message = new DivElement();
message.id = 'message2';
message.text = 'Подписывайся на рассылку новостей Dart.';
```

Для того, чтобы уменьшить объемы кода в следующем примере используется каскадный метод записи:

```java
var message = new DivElement()
    ..id = 'message2'
    ..text = 'Подписывайся на рассылку новостей Dart.';
```

Использование `id` и классов для задания стилей элементов лучший вариант их применения, но иногда может понадобиться применить стиль непосредственно к конкретному элементу:

```java
message.style
    ..fontWeight = 'bold'
    ..fontSize = '3em';
```

## Обработка событий

Чтобы Ваше приложение могло реагировать на такие события как нажатие мыши, изменения фокуса и тому подобные, необходимо добавить какую-нибудь прослушку событий (event listener). Добавлять прослушку событий можно абсолютно к любому элементу на странице. Отправка и передача событий довольно сложная тема; [Ознакомьтесь с деталями](http://www.w3.org/TR/DOM-Level-3-Events/#dom-event-architecture) если Вы только начинаете с ними работать.

Добавить прослушку событий можно с помощью `element.onEvent.listen(function)`, где `Event` это имя события, а `function` - его обработчик.

К примеру, вот так можно обрабатывать событие нажатия кнопки:

```java
// Находится элемент по id и к нему добавляется обработчик событий.
querySelector('#submitInfo').onClick.listen((e) {
  // Когда кнопка будет нажата, запустится этот код.
  submitData();
});
```

События могут распространяться вверх и вниз по дереву DOM. Чтобы узнать, какой элемент изначально запустил событие, можно использовать `e.target`:

```java
document.body.onClick.listen((e) {
  var clickedElem = e.target;
  print('Вы выбрали ${clickedElem.id} элемент.');
});
```

Чтобы узнать все события, которые можно обрабатывать с помощью event listener, ищите __"on*EventType*"__ в документации API класса [Element](http://api.dartlang.org/dart_html/Element.html) и его подклассов. Основные события:

- change
- blur
- keyDown
- keyUp
- mouseDown
- mouseUp